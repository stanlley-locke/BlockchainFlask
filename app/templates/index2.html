<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Blockchain Frontend</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: #fafafa;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"],
        input[type="number"],
        textarea {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            box-sizing: border-box;
        }
        button {
            background-color: #3498db;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        pre {
            background-color: #e8f0f7;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #333;
            border: 1px solid #d0e0f0;
        }
        .response-area {
            margin-top: 20px;
        }
        .wallet-info {
            background-color: #e6ffe6;
            border: 1px solid #aaffaa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .wallet-info p {
            margin: 5px 0;
        }
        .wallet-info strong {
            color: #28a745;
        }
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Python Blockchain Frontend</h1>
        <p>Interact with your Flask blockchain node.</p>
        <p><strong>Note:</strong> For this to work, your Flask app needs to be running, and you might need to enable CORS in your Flask app (see instructions).</p>
        <p><strong>Security Warning:</strong> Storing private keys in your browser's local storage is NOT secure for a real blockchain. This is for demonstration purposes only.</p>

        <div class="section">
            <h2>Your Wallet</h2>
            <div class="wallet-info" id="walletInfo">
                <p><strong>Public Key:</strong> <span id="currentPublicKey">None</span></p>
                <p><strong>Private Key (PEM):</strong> <span id="currentPrivateKey">None</span></p>
                <p><small>Keys are stored in browser's localStorage for convenience.</small></p>
            </div>
            <button onclick="generateWallet()">Generate New Wallet</button>
            <button onclick="clearWallet()">Clear Wallet</button>
            <div class="response-area">
                <h3>Wallet Response:</h3>
                <pre id="walletResponse"></pre>
            </div>
        </div>

        <div class="section">
            <h2>Mine Block</h2>
            <p>Mine a new block and receive the mining reward.</p>
            <button onclick="mineBlock()">Mine Block</button>
            <div class="response-area">
                <h3>Mine Response:</h3>
                <pre id="mineResponse"></pre>
            </div>
        </div>

        <div class="section">
            <h2>Create Transaction</h2>
            <label for="outputPublicKey">Recipient Public Key:</label>
            <input type="text" id="outputPublicKey" placeholder="Enter recipient's public key">

            <label for="amount">Amount:</label>
            <input type="number" id="amount" value="1" min="0.00000001" step="any">

            <label for="fee">Fee:</label>
            <input type="number" id="fee" value="0.01" min="0" step="any">

            <button onclick="createTransaction()">Create & Sign Transaction</button>
            <div class="response-area">
                <h3>Transaction Response:</h3>
                <pre id="transactionResponse"></pre>
            </div>
        </div>

        <div class="section">
            <h2>Check Balance</h2>
            <label for="balancePublicKey">Public Key to Check:</label>
            <input type="text" id="balancePublicKey" placeholder="Enter public key (defaults to yours)">
            <button onclick="checkBalance()">Check Balance</button>
            <div class="response-area">
                <h3>Balance Response:</h3>
                <pre id="balanceResponse"></pre>
            </div>
        </div>

        <div class="section">
            <h2>View Blockchain</h2>
            <button onclick="viewChain()">Get Full Chain</button>
            <div class="response-area">
                <h3>Chain Response:</h3>
                <pre id="chainResponse"></pre>
            </div>
        </div>

        <div class="section">
            <h2>Node Management</h2>
            <label for="nodeAddress">Node Address (e.g., http://127.0.0.1:5001):</label>
            <input type="text" id="nodeAddress" value="http://127.0.0.1:5001" placeholder="Enter node URL">
            <button onclick="registerNode()">Register Node</button>
            <button onclick="resolveConflicts()">Resolve Conflicts (Consensus)</button>
            <div class="response-area">
                <h3>Node Response:</h3>
                <pre id="nodeResponse"></pre>
            </div>
        </div>
    </div>

    <script>
        const FLASK_API_URL = 'http://127.0.0.1:5000'; // Make sure this matches your Flask app's address

        // DOM Elements
        const currentPublicKeySpan = document.getElementById('currentPublicKey');
        const currentPrivateKeySpan = document.getElementById('currentPrivateKey');
        const walletResponsePre = document.getElementById('walletResponse');
        const mineResponsePre = document.getElementById('mineResponse');
        const outputPublicKeyInput = document.getElementById('outputPublicKey');
        const amountInput = document.getElementById('amount');
        const feeInput = document.getElementById('fee');
        const transactionResponsePre = document.getElementById('transactionResponse');
        const balancePublicKeyInput = document.getElementById('balancePublicKey');
        const balanceResponsePre = document.getElementById('balanceResponse');
        const chainResponsePre = document.getElementById('chainResponse');
        const nodeAddressInput = document.getElementById('nodeAddress');
        const nodeResponsePre = document.getElementById('nodeResponse');

        let currentWallet = {
            publicKey: localStorage.getItem('publicKey') || null,
            privateKey: localStorage.getItem('privateKey') || null
        };

        function updateWalletInfo() {
            currentPublicKeySpan.textContent = currentWallet.publicKey || 'None';
            currentPrivateKeySpan.textContent = currentWallet.privateKey ? 'Stored (click "Clear Wallet" to remove)' : 'None';
            balancePublicKeyInput.value = currentWallet.publicKey || '';
            outputPublicKeyInput.value = ''; // Clear recipient field
        }

        function displayResponse(element, data) {
            element.textContent = JSON.stringify(data, null, 2);
            element.classList.remove('error'); // Remove error class if present
        }

        function displayError(element, message) {
            element.textContent = `Error: ${message}`;
            element.classList.add('error');
        }

        async function generateWallet() {
            try {
                const response = await fetch(`${FLASK_API_URL}/wallet/new`);
                const data = await response.json();
                displayResponse(walletResponsePre, data);

                if (response.ok) {
                    currentWallet.publicKey = data.public_key_hex;
                    currentWallet.privateKey = data.private_key_pem;
                    localStorage.setItem('publicKey', currentWallet.publicKey);
                    localStorage.setItem('privateKey', currentWallet.privateKey);
                    updateWalletInfo();
                } else {
                    displayError(walletResponsePre, data.message || 'Failed to generate wallet.');
                }
            } catch (error) {
                displayError(walletResponsePre, `Network error: ${error.message}`);
            }
        }

        function clearWallet() {
            currentWallet.publicKey = null;
            currentWallet.privateKey = null;
            localStorage.removeItem('publicKey');
            localStorage.removeItem('privateKey');
            updateWalletInfo();
            displayResponse(walletResponsePre, { message: "Wallet cleared from local storage." });
        }

        async function mineBlock() {
            if (!currentWallet.publicKey) {
                displayError(mineResponsePre, "Please generate or load a wallet first to receive mining rewards.");
                return;
            }
            try {
                const response = await fetch(`${FLASK_API_URL}/mine?miner_public_key=${currentWallet.publicKey}`);
                const data = await response.json();
                displayResponse(mineResponsePre, data);
                if (!response.ok) {
                    displayError(mineResponsePre, data.message || 'Failed to mine block.');
                }
            } catch (error) {
                displayError(mineResponsePre, `Network error: ${error.message}`);
            }
        }

        async function createTransaction() {
            if (!currentWallet.publicKey || !currentWallet.privateKey) {
                displayError(transactionResponsePre, "Please generate or load a wallet first to send transactions.");
                return;
            }

            const outputPublicKey = outputPublicKeyInput.value;
            const amount = parseFloat(amountInput.value);
            const fee = parseFloat(feeInput.value);

            if (!outputPublicKey || isNaN(amount) || amount <= 0 || isNaN(fee) || fee < 0) {
                displayError(transactionResponsePre, "Please fill in all transaction details correctly.");
                return;
            }

            try {
                const response = await fetch(`${FLASK_API_URL}/transactions/new`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input_public_key: currentWallet.publicKey,
                        output_public_key: outputPublicKey,
                        amount: amount,
                        fee: fee,
                        private_key_pem: currentWallet.privateKey
                    }),
                });
                const data = await response.json();
                displayResponse(transactionResponsePre, data);
                if (!response.ok) {
                    displayError(transactionResponsePre, data.message || 'Failed to create transaction.');
                }
            } catch (error) {
                displayError(transactionResponsePre, `Network error: ${error.message}`);
            }
        }

        async function checkBalance() {
            const publicKeyToCheck = balancePublicKeyInput.value || currentWallet.publicKey;
            if (!publicKeyToCheck) {
                displayError(balanceResponsePre, "Please enter a public key or generate/load your wallet.");
                return;
            }
            try {
                const response = await fetch(`${FLASK_API_URL}/utxos/${publicKeyToCheck}`);
                const data = await response.json();
                displayResponse(balanceResponsePre, data);
                if (!response.ok) {
                    displayError(balanceResponsePre, data.message || 'Failed to fetch balance.');
                }
            } catch (error) {
                displayError(balanceResponsePre, `Network error: ${error.message}`);
            }
        }

        async function viewChain() {
            try {
                const response = await fetch(`${FLASK_API_URL}/chain`);
                const data = await response.json();
                displayResponse(chainResponsePre, data);
                if (!response.ok) {
                    displayError(chainResponsePre, data.message || 'Failed to fetch chain.');
                }
            } catch (error) {
                displayError(chainResponsePre, `Network error: ${error.message}`);
            }
        }

        async function registerNode() {
            const nodeAddress = nodeAddressInput.value;
            if (!nodeAddress) {
                displayError(nodeResponsePre, "Please enter a node address to register.");
                return;
            }
            try {
                const response = await fetch(`${FLASK_API_URL}/nodes/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ nodes: [nodeAddress] }),
                });
                const data = await response.json();
                displayResponse(nodeResponsePre, data);
                if (!response.ok) {
                    displayError(nodeResponsePre, data.message || 'Failed to register node.');
                }
            } catch (error) {
                displayError(nodeResponsePre, `Network error: ${error.message}`);
            }
        }

        async function resolveConflicts() {
            try {
                const response = await fetch(`${FLASK_API_URL}/nodes/resolve`);
                const data = await response.json();
                displayResponse(nodeResponsePre, data);
                if (!response.ok) {
                    displayError(nodeResponsePre, data.message || 'Failed to resolve conflicts.');
                }
            } catch (error) {
                displayError(nodeResponsePre, `Network error: ${error.message}`);
            }
        }

        // Initialize wallet info on page load
        document.addEventListener('DOMContentLoaded', updateWalletInfo);
    </script>
</body>
</html>
